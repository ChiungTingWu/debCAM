---
title: "CAMTHC User Manual"
author: "Lulu Chen"
date: "`r Sys.Date()`"
output: 
  BiocStyle::html_document:
    toc: true
vignette: >
  %\VignetteIndexEntry{CAMTHC User Manual}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r setup, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
knitr::knit_hooks$set(webgl = rgl::hook_webgl)
```

# Introduction

Convex Analysis of Mixtures (CAM) is a fully unsupervised computational method to analyze tissue samples composed of unknown numbers and varying proportions of distinct subpopulations. CAM assumes that the measured expression level is the weighted sum of each subpopulationâ€™s expression, where the contribution from a single subpopulation is proportional to the abundance and specific expression of that subpopulation. This linear mixing model can be formulated as $\mathbf{X'=AS'}$. CAM can can identify molecular markers directly from the original mixed expression matrix, $\mathbf{X}$, and further estimate the constituent proportion matrix, $\mathbf{A}$, as well as subpopulation-specific expression profile matrix, $\mathbf{S}$.

`CAMTHC` is an R package developed for tissue heterogeneity characterization by CAM algorithm. It provides basic functions to perform unsupervised deconvolution on mixture expression profiles by CAM and some auxiliary functions to help understand the subpopulation-specific results. `CAMTHC` also implements functions to perform supervised deconlution based on prior knowledge of molecular markers, S matrix or A matrix. Semi-suprvised deconvolution can also be achieved by combining molecular markers from CAM and from prior knowledge to analyze mixture expressions.

# Quick start

The function `CAM()` includes all necessary steps to decompose a matrix of mixture expression prefiles. There are some optional steps upstream of `CAM()` that downsample the matrix for reducing running time. Each step in `CAM()` can also be performed seperately if you prefer a more flexiable workflow. More details will be introduced in sections below.

Starting your analysis by `CAM()`, you need to specify the range of possible subpopulation numbers and the percentage of low/high-expressed molecueles to be removed. Typically, 30% ~ 50% low-expressed genes can be removed from gene expression data. Much less low-expressed proteins are removed, e.g. 0% ~ 10%, due to a limited number of proteins in proteomics data. The removel of high-expressed molecules has much less impact on results, and usually set to be 0% ~ 10%.

```{r, eval=FALSE}
rCAM <- CAM(data, K = 2:5, thres.low = 0.30, thres.high = 0.95)
```

# Unsupervised Deconvolution

## Datatypes and Input Format

Theoretically, `CAMTHC` accepts any molecular expression data types as long as the expressions follow the linear mixing model. We have validated the feasibility of CAM in gene expression data (microarray, RNAseq), proteomics data and DNA methylation data. Requirements for the input expression data:

- be in non-log linear space with non-negative numerical values (i.e.>=0).
- be already processed by normalization and batch effect removal.
- no missing values; the molecules containig missing values shoulde be removed prior to CAM.
- no zero-expressed molecules; the molecules with zero expression in all samples should be removed prior to CAM.

The input expression data should be stored in a matrix. Data frames are also accepted and will be internally coerced into a matrix format before analysis. Each column in the matrix should be a tissue sample. Each row should be a probe/gene/protein/etc. Row names should be provided so that CAM can return the names of detected markers. Otherwize rows will be automatically named by 1,2,3,...

## CAM workflow

We use a data set downsampled from [GSE19830](https://www.ncbi.nlm.nih.gov/geo/query/acc.cgi?acc=GSE19830) as an example to show CAM workflow. This data set provides gene expression profiles of pure tissues (brain, liver, lung) and their biological mixtures with different proportions.  

```{r, echo=TRUE}
library(CAMTHC)

data(ratMix3) 
#ratMix3$X: X matrix cotaining mixtue expression profiless to be analyzed
#ratMix3$A: ground truth A matrix cotaining proportions
#ratMix3$S: ground truth S matrix containing subpopulation-specific expression profiles

data <- ratMix3$X
#10000 genes * 21 tissues
#meet the input data requirements
```

### Analysis by CAM

Unsupervised deconvolution can be achieved by the function `CAM()` with a simple setting as Section \@ref(quick-start) introduced. Other critial parameters are `dim.rdc` (reduced data dimension) and `cluster.num` (number of clusters). Increasing them will bring more time complexity. We can also specify `cores` for parallel computing configured by `r Biocpkg("BiocParallel")`. `cores = 0` will disable parallel computing. No `cores` argument will invoke one core for each element in `K`. The `seed` argument can help generate reproduciable results. 

```{r, echo=TRUE, message=FALSE}
rCAM <- CAM(data, K = 2:5, thres.low = 0.30, thres.high = 0.95, seed = 111)
#CAM return three sub results: 
#rCAM$PrepResult contains details corresponding to data preprocessing.
#rCAM$MGResult contains details corresponding to marker gene clusters detection.
#rCAM$ASestResult contains details corresponding to A and S matrix estimation.
```

### Estimated A and S matrix

The A and S matrix estimated by CAM with a fixed subpopultation number, e.g. K = 3, can be obtained by

```{r, echo=TRUE}
Aest <- rCAM$ASestResult$'3'$Aest
Sest <- rCAM$ASestResult$'3'$Sest
```
Or by
```{r, echo=TRUE}
m <- which(names(rCAM$ASestResult) == '3')
Aest <- rCAM$ASestResult[[m]]$Aest
Sest <- rCAM$ASestResult[[m]]$Sest
```

### Detected marker genes

The marker genes detected by CAM and used for A matrix estimation can be obtained by

```{r, echo=TRUE}
MGlist <- MGsforA(rCAM, K = 3) #for three subpopulations
```

Data preprocessing has filtered many genes, among which there are also some biologically-meaningful marker genes. So we need to check each gene again to find all the possible markers. Two statistics based on the subpopultiaon-specifc expressions are exploited to identify marker genes with certain thresholds. The first is OVE-FC (one versus everyone - fold change) (Yu et al. 2010). The second is the lower confidence bound of bootstrapped OVE-FC at $\alpha$ level. 

```{r, echo=TRUE}
MGstat <- MGstatistic(data, Aest, boot.alpha = 0.05, nboot = 1000)
MGlist.FC <- lapply(1:3, function(x) 
    rownames(MGstat)[MGstat$idx == x & MGstat$OVE.FC > 10])
MGlist.FCboot <- lapply(1:3, function(x) 
    rownames(MGstat)[MGstat$idx == x & MGstat$OVE.FC.alpha > 10])
```

### Simplex Plot - 2D

Fundamental to the success of CAM is that the scatter simplex of mixed expressions is a rotated and compressed version of the scatter simplex of pure expressions, where the marker genes are located at each vertex. `simplexplot()` function can show the scatter simplex and deteced marker genes in a 2D plot. The vertices in the high-dimenisonal simplex will still locate at extreme points of low-dimensional simplex. 

```{r, fig.height=6, fig.width=6}
simplexplot(data, Aest, MGlist)
simplexplot(data, Aest, MGlist.FC)
simplexplot(data, Aest, MGlist.FCboot)
```

The colors and the vertex order displayed in 2D plot can be changed as

```{r, fig.height=6, fig.width=6}
simplexplot(data, Aest, MGlist.FCboot, corner.order = c(2,1,3), 
            data.col = "blue", corner.col = c("red","orange","green"))
```

### Simplex Plot - 3D

We can also observe the convex cone and simplex of mixture expressions in 3D space by PCA. Note that PCA cannot gurantee the vertices will be still preserved as extreme points of the dimension-reduced simplex.

Code to show convex cone:

```{r, webgl=TRUE}
library(rgl)
Xp <- data %*% t(rCAM$PrepResult$W)
plot3d(Xp[, 1:3], col='gray', size=3, 
       xlim=range(Xp[,1]), ylim=range(Xp[,2:3]), zlim=range(Xp[,2:3]))
abclines3d(0,0,0, a=diag(3), col="black")
for(i in seq_along(MGlist)){
    points3d(Xp[MGlist[[i]], 1:3], col= rainbow(3)[i], size = 8)
}
```

Code to show simplex:

```{r, webgl=TRUE, message=FALSE}
library(rgl)
clear3d()
Xproj <- XWProj(data, rCAM$PrepResult$W)
Xp <- Xproj[,-1]
plot3d(Xp[, 1:3], col='gray', size=3, 
       xlim=range(Xp[,1:3]), ylim=range(Xp[,1:3]), zlim=range(Xp[,1:3]))
abclines3d(0,0,0, a=diag(3), col="black")
for(i in seq_along(MGlist)){
    points3d(Xp[MGlist[[i]], 1:3], col= rainbow(3)[i], size = 8)
}
```

### Model selection by MDL curves

We used MDL, a widely-adopted and consistent information theoretic criterion, to guide model selection. The underlying subpopulation number can be decided by minimizing the total description code length:

```{r, echo=TRUE}
MDL(rCAM)$mdls
```

The MDL curve can be shown by

```{r, fig.height=6, fig.width=6}
plot(MDL(rCAM), data.term = TRUE)
```

### Validation with Ground Truth

If the ground truth A and S matrix are availabe, the estimation from CAM can be evaluated:

```{r, echo=TRUE}
cor(Aest, ratMix3$A)
cor(Sest, ratMix3$S)
```

Considering the presence of many co-expressed genes (housekeeping genes) may dominate the correlation coefficients between ground truth and estimated expression profiles, it is better to assess correlation coefficients over marker genes only.

```{r, echo=TRUE}
unlist(lapply(1:3, function(k) {
    k.match <- which.max(cor(Aest[,k], ratMix3$A));
    mgk <- MGlist.FCboot[[k]];
    corr <- cor(Sest[mgk, k], ratMix3$S[mgk, k.match]);
    names(corr) <- colnames(ratMix3$A)[k.match];
    corr}))

```

## Alternative CAM workflow

There major steps in CAM (data preprocession, marker gene cluster detection, and matrix decomposition) can also be performed seperately as a more flexiable choise.

```{r, echo=TRUE}
#Data preprocession
rPrep <- CAMPrep(data, thres.low = 0.30, thres.high = 0.95, seed = 111)

#Marker gene cluster detection with a fixed K
rMGC <- CAMMGCluster(3, rPrep)

#A and S matrix estimation
rASest <- CAMASest(rMGC, rPrep, data)

#Obtain A and S matrix
Aest <- rASest$Aest
Sest <- rASest$Sest

#obtain marker gene list detected by CAM and used for A estimation
MGlist <- MGsforA(PrepResult = rPrep, MGResult = rMGC)

#obtain a full list of marker genes 
MGstat <- MGstatistic(data, Aest, boot.alpha = 0.05, nboot = 1000)
MGlist.FC <- lapply(1:3, function(x) 
    rownames(MGstat)[MGstat$idx == x & MGstat$OVE.FC > 10])
MGlist.FCboot <- lapply(1:3, function(x) 
    rownames(MGstat)[MGstat$idx == x & MGstat$OVE.FC.alpha > 10])
```

## Optional sample clustering

We have implemented PCA in `CAM()`/`CAMPrep()` to reduce data dimensions. Sample clusteirng, as another data dimension reduction method, is optional prior to `CAM()`/`CAMPrep()`. 

```{r, echo=TRUE, message=FALSE}
#clustering
library(apcluster)
apres <- apclusterK(negDistMat(r=2), t(data),  K = 10) 
#You can also use apcluster(), but need to make sure the number of clusters is large than potentional subpopulation number.

data.clusterMean <- lapply(slot(apres,"clusters"), 
                           function(x) rowMeans(data[, x, drop = FALSE]))
data.clusterMean <- do.call(cbind, data.clusterMean)

rCAM <- CAM(data.clusterMean, K = 2:5, thres.low = 0.30, thres.high = 0.95, 
            cores = 30, seed = 111)
# or rPrep <- CAMPrep(data.clusterMean, thres.low = 0.30, thres.high = 0.95, seed = 111)
```

We can still follow the workflow in \@ref(cam-workflow) or \@ref(alternative-cam-workflow) to obtain marker gene list and estimated S matrix. However, the estimated A matrix is for the new data composed of cluster centers. The A matrix for the origianl data can be obtained by

```{r, echo=TRUE}
Sest <- rCAM$ASestResult$'3'$Sest
MGlist <- MGsforA(rCAM, K = 3)
Aest <- AfromMarkers(data, MGlist)
```

## Case study
### GSE11058

[GSE11058](https://www.ncbi.nlm.nih.gov/geo/query/acc.cgi?acc=GSE11058) run four immune cell lines on microarrays as well as their mixtures of various relative proportions. The code chunk below shows how to use CAM to blindly seperate the four mixtures into four pure cell lines. Note that this data set contains 54613 probe/probesets. We can reduce running time by downsampling probe/probesets or remove more low-expressed genes (e.g. 70%).

```{r, echo=TRUE, message=FALSE}
#download data and phenotypes
library(GEOquery)
gsm<- getGEO('GSE11058')
pheno <- pData(phenoData(gsm[[1]]))$characteristics_ch1
mat <- exprs(gsm[[1]])
mat <- mat[-grep("^AFFX", rownames(mat)),]
mat.aggre <- sapply(unique(pheno), function(x) rowMeans(mat[,pheno == x]))
data <- mat.aggre[,5:8]

#running CAM
rCAM <- CAM(data, K = 4, thres.low = 0.70, thres.high = 0.95, 
            cores = 30, seed = 111)
Aest <- rCAM$ASestResult$'4'$Aest
Aest

#Use ground truth A to validate CAM-estimated A matrix
Atrue <- matrix(c(2.50, 0.50, 0.10, 0.02,
              1.25, 3.17, 4.95, 3.33,
              2.50, 4.75, 1.65, 3.33,
              3.75, 1.58, 3.30, 3.33), 4,4,
              dimnames = list(c("MixA", "MixB", "MixC","MixD"),
                               c("Jurkat", "IM-9", "Raji", "THP-1")))
Atrue <- Atrue / rowSums(Atrue)
Atrue
cor(Aest, Atrue)
```

### methylation

# Supervised/Semi-supervised Deconvolution
## Molecular markers are known

CAM algorithm can estimate A and S matrix based on blindly detected markers. Thus, we can also use part of CAM algorithm to estimate A and S matrix based on known markers.

```{r, echo=TRUE, eval=FALSE}
Aest <- AfromMarkers(data, MGlist)
#MGlist is a list of vectors, each of which contains known markers for one subpopulation
```

## S matrix is known

Many datasets provide expression profiles for purified cell lines or even every single cell, which can be treated as references of S matrix. Some methods use least squares techniques or support vector regression (CIBERSORT) to estimate A matrix based on known S matrix. `CAMTHC` will estimate A matrix by identified markers from known S matrix, which has better performance in terms of correlation coefficient with ground truth A matrix.  

```{r, echo=TRUE}
data <- ratMix3$X
S <- ratMix3$S #known S matrix

pMGstat <- MGstatistic(S, c("Liver","Brain","Lung"))
pMGlist.FC <- lapply(c("Liver","Brain","Lung"), function(x) 
    rownames(pMGstat)[pMGstat$idx == x & pMGstat$OVE.FC > 10])

Aest <- AfromMarkers(data, pMGlist.FC)
```

## A matrix is known

With known A matrix, `CAMTHC` estimates S matrix using non-negative least squares (NNLS) from `r CRANpkg("NMF")`, and further identify markers

```{r, echo=TRUE}
data <- ratMix3$X
A <- ratMix3$A #known A matrix

Sest <- t(NMF::.fcnnls(A, t(data))$coef)
MGstat <- MGstatistic(data, A)
```

## Semi-supervised Deconvolution

When prior information of markers, S matrix and/or A matrix is available, semi-supervised deconvoluton can also be performed by combining markers from prior information and markers identified by CAM. While supervised deconvolution cannot handle the underlying subpopulations without prior information, unsupervised deconvolution may miss the subpopulation without enough discrimination power. Therefore, semi-supervised deconvolution can take advantage of both methods.   

```{r, echo=TRUE, eval=FALSE}
Aest <- AfromMarkers(data, MGlist)
#MGlist is a list of vectors, each of which contains known markers and/or CAM-detected markers for one subpopulation
```

